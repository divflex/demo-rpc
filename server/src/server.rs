use std::time::Duration;

use anyhow::Ok;
use rpc::Hello;
use futures::{
    channel::oneshot,
    future::{self, AbortHandle},
    prelude::*,
};
use tarpc::{
    client, context,
    serde_transport::tcp,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use tokio::sync::{broadcast, mpsc};
use tracing::info;

#[derive(Clone, Debug)]
pub struct HelloServer {
    pub name: String,
    /// this is not necessary, try to call SingletonInstance through messaging
    /// But it seems very compilcated...
    pub tx: mpsc::Sender<String>
}

impl HelloServer {
    pub async fn start(self) -> anyhow::Result<()> {
        let listener = tcp::listen("localhost:9322", Json::default).await?;

        let instance = self.clone();
        // Ignore accept errors.
        listener
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                let server = instance.clone();
                println!("........");
                channel.execute(server.serve())
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;

        Ok(())
    }
}

#[tarpc::server]
impl Hello for HelloServer {
    /// requires to call SingletonInstance::say_hi()
    async fn say_hi(self, context: tarpc::context::Context) -> String {
        return "hi".to_string();
    }
}